/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp";
exports.ids = ["vendor-chunks/tmp"];
exports.modules = {

/***/ "(rsc)/./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = { fs: fs.constants, os: os.constants };\n\n/*\n * The working inner variables.\n */\nconst // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n  EXIT = 'exit',\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\n\nlet _gracefulCleanup = false;\n\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */\nfunction rimraf(dirPath, callback) {\n  return fs.rm(dirPath, { recursive: true }, callback);\n}\n\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */\nfunction FN_RIMRAF_SYNC(dirPath) {\n  return fs.rmSync(dirPath, { recursive: true });\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {\n    if (err) return cb(err);\n\n    let tries = sanitizedOptions.tries;\n    (function _getUniqueName() {\n      try {\n        const name = _generateTmpName(sanitizedOptions);\n\n        // check whether the path exists then retry if needed\n        fs.stat(name, function (err) {\n          /* istanbul ignore else */\n          if (!err) {\n            /* istanbul ignore else */\n            if (tries-- > 0) return _getUniqueName();\n\n            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n          }\n\n          cb(null, name);\n        });\n      } catch (err) {\n        cb(err);\n      }\n    })();\n  });\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);\n\n  let tries = sanitizedOptions.tries;\n  do {\n    const name = _generateTmpName(sanitizedOptions);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (let i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePath(name, tmpDir, cb) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  fs.stat(pathToResolve, function (err) {\n    if (err) {\n      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {\n        if (err) return cb(err);\n\n        cb(null, path.join(parentDir, path.basename(pathToResolve)));\n      });\n    } else {\n      fs.realpath(pathToResolve, cb);\n    }\n  });\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePathSync(name, tmpDir) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  try {\n    fs.statSync(pathToResolve);\n    return fs.realpathSync(pathToResolve);\n  } catch (_err) {\n    const parentDir = fs.realpathSync(path.dirname(pathToResolve));\n\n    return path.join(parentDir, path.basename(pathToResolve));\n  }\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name)) {\n    return path.join(tmpDir, opts.dir, opts.name);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template)) {\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts and sanitizes the basic options.\n *\n * @private\n */\nfunction _assertOptionsBase(options) {\n  if (!_isUndefined(options.name)) {\n    const name = options.name;\n\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found \"${name}\".`);\n\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    const basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`name option must not contain a path, found \"${name}\".`);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {\n    throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n\n  /* istanbul ignore else */\n  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n  }\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Gets the relative directory to tmpDir.\n *\n * @private\n */\nfunction _getRelativePath(option, name, tmpDir, cb) {\n  if (_isUndefined(name)) return cb(null);\n\n  _resolvePath(name, tmpDir, function (err, resolvedPath) {\n    if (err) return cb(err);\n\n    const relativePath = path.relative(tmpDir, resolvedPath);\n\n    if (!resolvedPath.startsWith(tmpDir)) {\n      return cb(new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`));\n    }\n\n    cb(null, relativePath);\n  });\n}\n\n/**\n * Gets the relative path to tmpDir.\n *\n * @private\n */\nfunction _getRelativePathSync(option, name, tmpDir) {\n  if (_isUndefined(name)) return;\n\n  const resolvedPath = _resolvePathSync(name, tmpDir);\n  const relativePath = path.relative(tmpDir, resolvedPath);\n\n  if (!resolvedPath.startsWith(tmpDir)) {\n    throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`);\n  }\n\n  return relativePath;\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptions(options, cb) {\n  _getTmpDir(options, function (err, tmpDir) {\n    if (err) return cb(err);\n\n    options.tmpdir = tmpDir;\n\n    try {\n      _assertOptionsBase(options, tmpDir);\n    } catch (err) {\n      return cb(err);\n    }\n\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {\n      if (err) return cb(err);\n\n      options.dir = _isUndefined(dir) ? '' : dir;\n\n      // sanitize further if template is relative to options.dir\n      _getRelativePath('template', options.template, tmpDir, function (err, template) {\n        if (err) return cb(err);\n\n        options.template = template;\n\n        cb(null, options);\n      });\n    });\n  });\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptionsSync(options) {\n  const tmpDir = (options.tmpdir = _getTmpDirSync(options));\n\n  _assertOptionsBase(options, tmpDir);\n\n  const dir = _getRelativePathSync('dir', options.dir, tmpDir);\n  options.dir = _isUndefined(dir) ? '' : dir;\n\n  options.template = _getRelativePathSync('template', options.template, tmpDir);\n\n  return options;\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDir(options, cb) {\n  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDirSync(options) {\n  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDirSync();\n  }\n}));\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCLG1CQUFtQjtBQUNuQix1QkFBdUI7O0FBRXZCLHNCQUFzQjtBQUN0QiwwQkFBMEI7O0FBRTFCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlbmlsYWlhbi1ndXJ1LXNkLy4vbm9kZV9tb2R1bGVzL3RtcC9saWIvdG1wLmpzP2MxNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUbXBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBLQVJBU1pJIElzdHZhbiA8Z2l0aHViQHNwYW0ucmFzemkuaHU+XG4gKlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLypcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IF9jID0geyBmczogZnMuY29uc3RhbnRzLCBvczogb3MuY29uc3RhbnRzIH07XG5cbi8qXG4gKiBUaGUgd29ya2luZyBpbm5lciB2YXJpYWJsZXMuXG4gKi9cbmNvbnN0IC8vIHRoZSByYW5kb20gY2hhcmFjdGVycyB0byBjaG9vc2UgZnJvbVxuICBSQU5ET01fQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuICBURU1QTEFURV9QQVRURVJOID0gL1hYWFhYWC8sXG4gIERFRkFVTFRfVFJJRVMgPSAzLFxuICBDUkVBVEVfRkxBR1MgPSAoX2MuT19DUkVBVCB8fCBfYy5mcy5PX0NSRUFUKSB8IChfYy5PX0VYQ0wgfHwgX2MuZnMuT19FWENMKSB8IChfYy5PX1JEV1IgfHwgX2MuZnMuT19SRFdSKSxcbiAgLy8gY29uc3RhbnRzIGFyZSBvZmYgb24gdGhlIHdpbmRvd3MgcGxhdGZvcm0gYW5kIHdpbGwgbm90IG1hdGNoIHRoZSBhY3R1YWwgZXJybm8gY29kZXNcbiAgSVNfV0lOMzIgPSBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInLFxuICBFQkFERiA9IF9jLkVCQURGIHx8IF9jLm9zLmVycm5vLkVCQURGLFxuICBFTk9FTlQgPSBfYy5FTk9FTlQgfHwgX2Mub3MuZXJybm8uRU5PRU5ULFxuICBESVJfTU9ERSA9IDBvNzAwIC8qIDQ0OCAqLyxcbiAgRklMRV9NT0RFID0gMG82MDAgLyogMzg0ICovLFxuICBFWElUID0gJ2V4aXQnLFxuICAvLyB0aGlzIHdpbGwgaG9sZCB0aGUgb2JqZWN0cyBuZWVkIHRvIGJlIHJlbW92ZWQgb24gZXhpdFxuICBfcmVtb3ZlT2JqZWN0cyA9IFtdLFxuICAvLyBBUEkgY2hhbmdlIGluIGZzLnJtZGlyU3luYyBsZWFkcyB0byBlcnJvciB3aGVuIHBhc3NpbmcgaW4gYSBzZWNvbmQgcGFyYW1ldGVyLCBlLmcuIHRoZSBjYWxsYmFja1xuICBGTl9STURJUl9TWU5DID0gZnMucm1kaXJTeW5jLmJpbmQoZnMpO1xuXG5sZXQgX2dyYWNlZnVsQ2xlYW51cCA9IGZhbHNlO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgaXRzIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJQYXRoIHBhdGggb2YgZGlyZWN0b3J5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJpbXJhZihkaXJQYXRoLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnMucm0oZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgaXRzIGNvbnRlbnRzLCBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJQYXRoIHBhdGggb2YgZGlyZWN0b3J5IHRvIHJlbW92ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRk5fUklNUkFGX1NZTkMoZGlyUGF0aCkge1xuICByZXR1cm4gZnMucm1TeW5jKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xufVxuXG4vKipcbiAqIEdldHMgYSB0ZW1wb3JhcnkgZmlsZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8dG1wTmFtZUNhbGxiYWNrKX0gb3B0aW9ucyBvcHRpb25zIG9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gez90bXBOYW1lQ2FsbGJhY2t9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0bXBOYW1lKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICBfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zKG9wdHMsIGZ1bmN0aW9uIChlcnIsIHNhbml0aXplZE9wdGlvbnMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIGxldCB0cmllcyA9IHNhbml0aXplZE9wdGlvbnMudHJpZXM7XG4gICAgKGZ1bmN0aW9uIF9nZXRVbmlxdWVOYW1lKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IF9nZW5lcmF0ZVRtcE5hbWUoc2FuaXRpemVkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcGF0aCBleGlzdHMgdGhlbiByZXRyeSBpZiBuZWVkZWRcbiAgICAgICAgZnMuc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0cmllcy0tID4gMCkgcmV0dXJuIF9nZXRVbmlxdWVOYW1lKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCAnICsgbmFtZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgdG1wTmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkIG9yIGNvdWxkIG5vdCBnZW5lcmF0ZSBhIGZpbGVuYW1lXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBzYW5pdGl6ZWRPcHRpb25zID0gX2Fzc2VydEFuZFNhbml0aXplT3B0aW9uc1N5bmMob3B0cyk7XG5cbiAgbGV0IHRyaWVzID0gc2FuaXRpemVkT3B0aW9ucy50cmllcztcbiAgZG8ge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKHNhbml0aXplZE9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBmcy5zdGF0U3luYyhuYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH0gd2hpbGUgKHRyaWVzLS0gPiAwKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIG9wZW5zIGEgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxmaWxlQ2FsbGJhY2spfSBvcHRpb25zIHRoZSBjb25maWcgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb3IgbnVsbCBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSB7P2ZpbGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmlsZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgLy8gZ2V0cyBhIHRlbXBvcmFyeSBmaWxlbmFtZVxuICB0bXBOYW1lKG9wdHMsIGZ1bmN0aW9uIF90bXBOYW1lQ3JlYXRlZChlcnIsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIGFuZCBvcGVuIHRoZSBmaWxlXG4gICAgZnMub3BlbihuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUsIGZ1bmN0aW9uIF9maWxlQ3JlYXRlZChlcnIsIGZkKSB7XG4gICAgICAvKiBpc3RhbmJ1IGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKG9wdHMuZGlzY2FyZERlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiBfZGlzY2FyZENhbGxiYWNrKHBvc3NpYmxlRXJyKSB7XG4gICAgICAgICAgLy8gdGhlIGNoYW5jZSBvZiBnZXR0aW5nIGFuIGVycm9yIG9uIGNsb3NlIGhlcmUgaXMgcmF0aGVyIGxvdyBhbmQgbWlnaHQgb2NjdXIgaW4gdGhlIG1vc3QgZWRnaWVzdCBjYXNlcyBvbmx5XG4gICAgICAgICAgcmV0dXJuIGNiKHBvc3NpYmxlRXJyLCBuYW1lLCB1bmRlZmluZWQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIC0xLCBvcHRzLCBmYWxzZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRldGFjaERlc2NyaXB0b3IgcGFzc2VzIHRoZSBkZXNjcmlwdG9yIHdoZXJlYXMgZGlzY2FyZERlc2NyaXB0b3IgY2xvc2VzIGl0LCBlaXRoZXIgd2F5LCB3ZSBubyBsb25nZXIgY2FyZVxuICAgICAgICAvLyBhYm91dCB0aGUgZGVzY3JpcHRvclxuICAgICAgICBjb25zdCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID0gb3B0cy5kaXNjYXJkRGVzY3JpcHRvciB8fCBvcHRzLmRldGFjaERlc2NyaXB0b3I7XG4gICAgICAgIGNiKG51bGwsIG5hbWUsIGZkLCBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBmaWxlLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0ZpbGVTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSwgZmQgYW5kIHJlbW92ZUNhbGxiYWNrXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2Fubm90IGNyZWF0ZSBhIGZpbGVcbiAqL1xuZnVuY3Rpb24gZmlsZVN5bmMob3B0aW9ucykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICBsZXQgZmQgPSBmcy5vcGVuU3luYyhuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfGRpckNhbGxiYWNrKX0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2RpckNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBkaXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZGlyZWN0b3J5XG4gICAgZnMubWtkaXIobmFtZSwgb3B0cy5tb2RlIHx8IERJUl9NT0RFLCBmdW5jdGlvbiBfZGlyQ3JlYXRlZChlcnIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgY2IobnVsbCwgbmFtZSwgX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBmYWxzZSkpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGRpci5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtEaXJTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBjYW5ub3QgY3JlYXRlIGEgZGlyZWN0b3J5XG4gKi9cbmZ1bmN0aW9uIGRpclN5bmMob3B0aW9ucykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IG5hbWUgPSB0bXBOYW1lU3luYyhvcHRzKTtcbiAgZnMubWtkaXJTeW5jKG5hbWUsIG9wdHMubW9kZSB8fCBESVJfTU9ERSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIHRydWUpXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBmaWxlcyBhc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmRQYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRmlsZUFzeW5jKGZkUGF0aCwgbmV4dCkge1xuICBjb25zdCBfaGFuZGxlciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmICFfaXNFTk9FTlQoZXJyKSkge1xuICAgICAgLy8gcmVyYWlzZSBhbnkgdW5hbnRpY2lwYXRlZCBlcnJvclxuICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICB9O1xuXG4gIGlmICgwIDw9IGZkUGF0aFswXSlcbiAgICBmcy5jbG9zZShmZFBhdGhbMF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZzLnVubGluayhmZFBhdGhbMV0sIF9oYW5kbGVyKTtcbiAgICB9KTtcbiAgZWxzZSBmcy51bmxpbmsoZmRQYXRoWzFdLCBfaGFuZGxlcik7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBmaWxlcyBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmZFBhdGhcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVGaWxlU3luYyhmZFBhdGgpIHtcbiAgbGV0IHJldGhyb3duRXhjZXB0aW9uID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBpZiAoMCA8PSBmZFBhdGhbMF0pIGZzLmNsb3NlU3luYyhmZFBhdGhbMF0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcmVyYWlzZSBhbnkgdW5hbnRpY2lwYXRlZCBlcnJvclxuICAgIGlmICghX2lzRUJBREYoZSkgJiYgIV9pc0VOT0VOVChlKSkgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgZnMudW5saW5rU3luYyhmZFBhdGhbMV0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIGlmICghX2lzRU5PRU5UKGUpKSByZXRocm93bkV4Y2VwdGlvbiA9IGU7XG4gICAgfVxuICB9XG4gIGlmIChyZXRocm93bkV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgIHRocm93IHJldGhyb3duRXhjZXB0aW9uO1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogZmlsZVN5bmMgb3IgZmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7ZmlsZUNhbGxiYWNrIHwgZmlsZUNhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGZkLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soX3JlbW92ZUZpbGVTeW5jLCBbZmQsIG5hbWVdLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlQXN5bmMsIFtmZCwgbmFtZV0sIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIF9yZW1vdmVPYmplY3RzLnVuc2hpZnQocmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICByZXR1cm4gc3luYyA/IHJlbW92ZUNhbGxiYWNrU3luYyA6IHJlbW92ZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogdG1wRmlsZVN5bmMgb3IgdG1wRmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uID0gb3B0cy51bnNhZmVDbGVhbnVwID8gcmltcmFmIDogZnMucm1kaXIuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uU3luYyA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IEZOX1JJTVJBRl9TWU5DIDogRk5fUk1ESVJfU1lOQztcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2tTeW5jID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvblN5bmMsIG5hbWUsIHN5bmMpO1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIG5hbWUsIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBUaGUgY2xlYW51cCBjYWxsYmFjayBpcyBzYXZlIHRvIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIFN1YnNlcXVlbnQgaW52b2NhdGlvbnMgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbW92ZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU9yRGlyTmFtZVxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmM/fSBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKiBAcmV0dXJucyB7Y2xlYW51cENhbGxiYWNrIHwgY2xlYW51cENhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIGZpbGVPckRpck5hbWUsIHN5bmMsIGNsZWFudXBDYWxsYmFja1N5bmMpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGlmIHN5bmMgaXMgdHJ1ZSwgdGhlIG5leHQgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZFxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgLy8gcmVtb3ZlIGNsZWFudXBDYWxsYmFjayBmcm9tIGNhY2hlXG4gICAgICBjb25zdCB0b1JlbW92ZSA9IGNsZWFudXBDYWxsYmFja1N5bmMgfHwgX2NsZWFudXBDYWxsYmFjaztcbiAgICAgIGNvbnN0IGluZGV4ID0gX3JlbW92ZU9iamVjdHMuaW5kZXhPZih0b1JlbW92ZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGluZGV4ID49IDApIF9yZW1vdmVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBpZiAoc3luYyB8fCByZW1vdmVGdW5jdGlvbiA9PT0gRk5fUk1ESVJfU1lOQyB8fCByZW1vdmVGdW5jdGlvbiA9PT0gRk5fUklNUkFGX1NZTkMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZ1bmN0aW9uKGZpbGVPckRpck5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZ1bmN0aW9uKGZpbGVPckRpck5hbWUsIG5leHQgfHwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZ2FyYmFnZSBjb2xsZWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dhcmJhZ2VDb2xsZWN0b3IoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghX2dyYWNlZnVsQ2xlYW51cCkgcmV0dXJuO1xuXG4gIC8vIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQgcmVtb3ZlcyBpdHNlbGYgZnJvbSBfcmVtb3ZlT2JqZWN0cyxcbiAgLy8gbG9vcCB1bnRpbCBfcmVtb3ZlT2JqZWN0cyBpcyBlbXB0eVxuICB3aGlsZSAoX3JlbW92ZU9iamVjdHMubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9yZW1vdmVPYmplY3RzWzBdKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gYWxyZWFkeSByZW1vdmVkP1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJhbmRvbSBuYW1lIGdlbmVyYXRvciBiYXNlZCBvbiBjcnlwdG8uXG4gKiBBZGFwdGVkIGZyb20gaHR0cDovL2Jsb2cudG9tcGF3bGFrLm9yZy9ob3ctdG8tZ2VuZXJhdGUtcmFuZG9tLXZhbHVlcy1ub2RlanMtamF2YXNjcmlwdFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBob3dNYW55XG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBuYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmFuZG9tQ2hhcnMoaG93TWFueSkge1xuICBsZXQgdmFsdWUgPSBbXSxcbiAgICBybmQgPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvIG5vdCBmYWlsIGJlY2F1c2Ugd2UgcmFuIG91dCBvZiBlbnRyb3B5XG4gIHRyeSB7XG4gICAgcm5kID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcm5kID0gY3J5cHRvLnBzZXVkb1JhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICB2YWx1ZS5wdXNoKFJBTkRPTV9DSEFSU1tybmRbaV0gJSBSQU5ET01fQ0hBUlMubGVuZ3RoXSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUuam9pbignJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGBvYmpgIHBhcmFtZXRlciBpcyBkZWZpbmVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBmdW5jdGlvbiBhcmd1bWVudHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoZWxwcyB0byBoYXZlIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfG51bGx8dW5kZWZpbmVkfEZ1bmN0aW9uKX0gb3B0aW9uc1xuICogQHBhcmFtIHs/RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBhcnNlZCBhcmd1bWVudHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjaykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gW3t9LCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICByZXR1cm4gW3t9LCBjYWxsYmFja107XG4gIH1cblxuICAvLyBjb3B5IG9wdGlvbnMgc28gd2UgZG8gbm90IGxlYWsgdGhlIGNoYW5nZXMgd2UgbWFrZSBpbnRlcm5hbGx5XG4gIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucykpIHtcbiAgICBhY3R1YWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gW2FjdHVhbE9wdGlvbnMsIGNhbGxiYWNrXTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBzcGVjaWZpZWQgcGF0aCBuYW1lIGluIHJlc3BlY3QgdG8gdG1wRGlyLlxuICpcbiAqIFRoZSBzcGVjaWZpZWQgbmFtZSBtaWdodCBpbmNsdWRlIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cywgZS5nLiAuLi9cbiAqIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSBpbiBvcmRlciB0byBiZSBzdXJlIHRoYXQgaXMgaXMgbG9jYXRlZCBpbnNpZGUgdG1wRGlyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQYXRoKG5hbWUsIHRtcERpciwgY2IpIHtcbiAgY29uc3QgcGF0aFRvUmVzb2x2ZSA9IHBhdGguaXNBYnNvbHV0ZShuYW1lKSA/IG5hbWUgOiBwYXRoLmpvaW4odG1wRGlyLCBuYW1lKTtcblxuICBmcy5zdGF0KHBhdGhUb1Jlc29sdmUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmcy5yZWFscGF0aChwYXRoLmRpcm5hbWUocGF0aFRvUmVzb2x2ZSksIGZ1bmN0aW9uIChlcnIsIHBhcmVudERpcikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgICBjYihudWxsLCBwYXRoLmpvaW4ocGFyZW50RGlyLCBwYXRoLmJhc2VuYW1lKHBhdGhUb1Jlc29sdmUpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnMucmVhbHBhdGgocGF0aFRvUmVzb2x2ZSwgY2IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgc3BlY2lmaWVkIHBhdGggbmFtZSBpbiByZXNwZWN0IHRvIHRtcERpci5cbiAqXG4gKiBUaGUgc3BlY2lmaWVkIG5hbWUgbWlnaHQgaW5jbHVkZSByZWxhdGl2ZSBwYXRoIGNvbXBvbmVudHMsIGUuZy4gLi4vXG4gKiBzbyB3ZSBuZWVkIHRvIHJlc29sdmUgaW4gb3JkZXIgdG8gYmUgc3VyZSB0aGF0IGlzIGlzIGxvY2F0ZWQgaW5zaWRlIHRtcERpclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUGF0aFN5bmMobmFtZSwgdG1wRGlyKSB7XG4gIGNvbnN0IHBhdGhUb1Jlc29sdmUgPSBwYXRoLmlzQWJzb2x1dGUobmFtZSkgPyBuYW1lIDogcGF0aC5qb2luKHRtcERpciwgbmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBmcy5zdGF0U3luYyhwYXRoVG9SZXNvbHZlKTtcbiAgICByZXR1cm4gZnMucmVhbHBhdGhTeW5jKHBhdGhUb1Jlc29sdmUpO1xuICB9IGNhdGNoIChfZXJyKSB7XG4gICAgY29uc3QgcGFyZW50RGlyID0gZnMucmVhbHBhdGhTeW5jKHBhdGguZGlybmFtZShwYXRoVG9SZXNvbHZlKSk7XG5cbiAgICByZXR1cm4gcGF0aC5qb2luKHBhcmVudERpciwgcGF0aC5iYXNlbmFtZShwYXRoVG9SZXNvbHZlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdGVtcG9yYXJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBuZXcgcmFuZG9tIG5hbWUgYWNjb3JkaW5nIHRvIG9wdHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZVRtcE5hbWUob3B0cykge1xuICBjb25zdCB0bXBEaXIgPSBvcHRzLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLm5hbWUpKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBvcHRzLm5hbWUpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0cy50ZW1wbGF0ZSkpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMudGVtcGxhdGUpLnJlcGxhY2UoVEVNUExBVEVfUEFUVEVSTiwgX3JhbmRvbUNoYXJzKDYpKTtcbiAgfVxuXG4gIC8vIHByZWZpeCBhbmQgcG9zdGZpeFxuICBjb25zdCBuYW1lID0gW1xuICAgIG9wdHMucHJlZml4ID8gb3B0cy5wcmVmaXggOiAndG1wJyxcbiAgICAnLScsXG4gICAgcHJvY2Vzcy5waWQsXG4gICAgJy0nLFxuICAgIF9yYW5kb21DaGFycygxMiksXG4gICAgb3B0cy5wb3N0Zml4ID8gJy0nICsgb3B0cy5wb3N0Zml4IDogJydcbiAgXS5qb2luKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG5hbWUpO1xufVxuXG4vKipcbiAqIEFzc2VydHMgYW5kIHNhbml0aXplcyB0aGUgYmFzaWMgb3B0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0T3B0aW9uc0Jhc2Uob3B0aW9ucykge1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpKSB7XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZTtcblxuICAgIC8vIGFzc2VydCB0aGF0IG5hbWUgaXMgbm90IGFic29sdXRlIGFuZCBkb2VzIG5vdCBjb250YWluIGEgcGF0aFxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUobmFtZSkpIHRocm93IG5ldyBFcnJvcihgbmFtZSBvcHRpb24gbXVzdCBub3QgY29udGFpbiBhbiBhYnNvbHV0ZSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcblxuICAgIC8vIG11c3Qgbm90IGZhaWwgb24gdmFsaWQgLjxuYW1lPiBvciAuLjxuYW1lPiBvciBzaW1pbGFyIHN1Y2ggY29uc3RydWN0c1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShuYW1lKTtcbiAgICBpZiAoYmFzZW5hbWUgPT09ICcuLicgfHwgYmFzZW5hbWUgPT09ICcuJyB8fCBiYXNlbmFtZSAhPT0gbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmFtZSBvcHRpb24gbXVzdCBub3QgY29udGFpbiBhIHBhdGgsIGZvdW5kIFwiJHtuYW1lfVwiLmApO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy50ZW1wbGF0ZSkgJiYgIW9wdGlvbnMudGVtcGxhdGUubWF0Y2goVEVNUExBVEVfUEFUVEVSTikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUsIGZvdW5kIFwiJHtvcHRpb25zLnRlbXBsYXRlfVwiLmApO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCghX2lzVW5kZWZpbmVkKG9wdGlvbnMudHJpZXMpICYmIGlzTmFOKG9wdGlvbnMudHJpZXMpKSB8fCBvcHRpb25zLnRyaWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmllcywgZm91bmQgXCIke29wdGlvbnMudHJpZXN9XCIuYCk7XG4gIH1cblxuICAvLyBpZiBhIG5hbWUgd2FzIHNwZWNpZmllZCB3ZSB3aWxsIHRyeSBvbmNlXG4gIG9wdGlvbnMudHJpZXMgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5uYW1lKSA/IG9wdGlvbnMudHJpZXMgfHwgREVGQVVMVF9UUklFUyA6IDE7XG4gIG9wdGlvbnMua2VlcCA9ICEhb3B0aW9ucy5rZWVwO1xuICBvcHRpb25zLmRldGFjaERlc2NyaXB0b3IgPSAhIW9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgb3B0aW9ucy5kaXNjYXJkRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kaXNjYXJkRGVzY3JpcHRvcjtcbiAgb3B0aW9ucy51bnNhZmVDbGVhbnVwID0gISFvcHRpb25zLnVuc2FmZUNsZWFudXA7XG5cbiAgLy8gZm9yIGNvbXBsZXRlbmVzcycgc2FrZSBvbmx5LCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gIG9wdGlvbnMucHJlZml4ID0gX2lzVW5kZWZpbmVkKG9wdGlvbnMucHJlZml4KSA/ICcnIDogb3B0aW9ucy5wcmVmaXg7XG4gIG9wdGlvbnMucG9zdGZpeCA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnBvc3RmaXgpID8gJycgOiBvcHRpb25zLnBvc3RmaXg7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcmVsYXRpdmUgZGlyZWN0b3J5IHRvIHRtcERpci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0UmVsYXRpdmVQYXRoKG9wdGlvbiwgbmFtZSwgdG1wRGlyLCBjYikge1xuICBpZiAoX2lzVW5kZWZpbmVkKG5hbWUpKSByZXR1cm4gY2IobnVsbCk7XG5cbiAgX3Jlc29sdmVQYXRoKG5hbWUsIHRtcERpciwgZnVuY3Rpb24gKGVyciwgcmVzb2x2ZWRQYXRoKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHRtcERpciwgcmVzb2x2ZWRQYXRoKTtcblxuICAgIGlmICghcmVzb2x2ZWRQYXRoLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IGJlIHJlbGF0aXZlIHRvIFwiJHt0bXBEaXJ9XCIsIGZvdW5kIFwiJHtyZWxhdGl2ZVBhdGh9XCIuYCkpO1xuICAgIH1cblxuICAgIGNiKG51bGwsIHJlbGF0aXZlUGF0aCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHJlbGF0aXZlIHBhdGggdG8gdG1wRGlyLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRSZWxhdGl2ZVBhdGhTeW5jKG9wdGlvbiwgbmFtZSwgdG1wRGlyKSB7XG4gIGlmIChfaXNVbmRlZmluZWQobmFtZSkpIHJldHVybjtcblxuICBjb25zdCByZXNvbHZlZFBhdGggPSBfcmVzb2x2ZVBhdGhTeW5jKG5hbWUsIHRtcERpcik7XG4gIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodG1wRGlyLCByZXNvbHZlZFBhdGgpO1xuXG4gIGlmICghcmVzb2x2ZWRQYXRoLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IGJlIHJlbGF0aXZlIHRvIFwiJHt0bXBEaXJ9XCIsIGZvdW5kIFwiJHtyZWxhdGl2ZVBhdGh9XCIuYCk7XG4gIH1cblxuICByZXR1cm4gcmVsYXRpdmVQYXRoO1xufVxuXG4vKipcbiAqIEFzc2VydHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG9wdGlvbnMgYXJlIHZhbGlkLCBhbHNvIHNhbml0aXplcyBvcHRpb25zIGFuZCBwcm92aWRlcyBzYW5lIGRlZmF1bHRzIGZvciBtaXNzaW5nXG4gKiBvcHRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0aW9ucywgY2IpIHtcbiAgX2dldFRtcERpcihvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0bXBEaXIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIG9wdGlvbnMudG1wZGlyID0gdG1wRGlyO1xuXG4gICAgdHJ5IHtcbiAgICAgIF9hc3NlcnRPcHRpb25zQmFzZShvcHRpb25zLCB0bXBEaXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2FuaXRpemUgZGlyLCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gICAgX2dldFJlbGF0aXZlUGF0aCgnZGlyJywgb3B0aW9ucy5kaXIsIHRtcERpciwgZnVuY3Rpb24gKGVyciwgZGlyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgb3B0aW9ucy5kaXIgPSBfaXNVbmRlZmluZWQoZGlyKSA/ICcnIDogZGlyO1xuXG4gICAgICAvLyBzYW5pdGl6ZSBmdXJ0aGVyIGlmIHRlbXBsYXRlIGlzIHJlbGF0aXZlIHRvIG9wdGlvbnMuZGlyXG4gICAgICBfZ2V0UmVsYXRpdmVQYXRoKCd0ZW1wbGF0ZScsIG9wdGlvbnMudGVtcGxhdGUsIHRtcERpciwgZnVuY3Rpb24gKGVyciwgdGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgICAgIGNiKG51bGwsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFzc2VydHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG9wdGlvbnMgYXJlIHZhbGlkLCBhbHNvIHNhbml0aXplcyBvcHRpb25zIGFuZCBwcm92aWRlcyBzYW5lIGRlZmF1bHRzIGZvciBtaXNzaW5nXG4gKiBvcHRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnNTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3QgdG1wRGlyID0gKG9wdGlvbnMudG1wZGlyID0gX2dldFRtcERpclN5bmMob3B0aW9ucykpO1xuXG4gIF9hc3NlcnRPcHRpb25zQmFzZShvcHRpb25zLCB0bXBEaXIpO1xuXG4gIGNvbnN0IGRpciA9IF9nZXRSZWxhdGl2ZVBhdGhTeW5jKCdkaXInLCBvcHRpb25zLmRpciwgdG1wRGlyKTtcbiAgb3B0aW9ucy5kaXIgPSBfaXNVbmRlZmluZWQoZGlyKSA/ICcnIDogZGlyO1xuXG4gIG9wdGlvbnMudGVtcGxhdGUgPSBfZ2V0UmVsYXRpdmVQYXRoU3luYygndGVtcGxhdGUnLCBvcHRpb25zLnRlbXBsYXRlLCB0bXBEaXIpO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVCQURGIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRUJBREYoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FQkFERiwgJ0VCQURGJyk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRU5PRU5UIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRU5PRU5UKGVycm9yKSB7XG4gIHJldHVybiBfaXNFeHBlY3RlZEVycm9yKGVycm9yLCAtRU5PRU5ULCAnRU5PRU5UJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIG1hdGNoZXMgdGhlIGFjdHVhbCBjb2RlIGFuZCBlcnJubyxcbiAqIHdoaWNoIHdpbGwgZGlmZmVyIGJldHdlZW4gdGhlIHN1cHBvcnRlZCBub2RlIHZlcnNpb25zLlxuICpcbiAqIC0gTm9kZSA+PSA3LjA6XG4gKiAgIGVycm9yLmNvZGUge3N0cmluZ31cbiAqICAgZXJyb3IuZXJybm8ge251bWJlcn0gYW55IG51bWVyaWNhbCB2YWx1ZSB3aWxsIGJlIG5lZ2F0ZWRcbiAqXG4gKiBDQVZFQVRcbiAqXG4gKiBPbiB3aW5kb3dzLCB0aGUgZXJybm8gZm9yIEVCQURGIGlzIC00MDgzIGJ1dCBvcy5jb25zdGFudHMuZXJybm8uRUJBREYgaXMgZGlmZmVyZW50IGFuZCB3ZSBtdXN0IGFzc3VtZSB0aGF0IEVOT0VOVFxuICogaXMgbm8gZGlmZmVyZW50IGhlcmUuXG4gKlxuICogQHBhcmFtIHtTeXN0ZW1FcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJub1xuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIGVycm5vLCBjb2RlKSB7XG4gIHJldHVybiBJU19XSU4zMiA/IGVycm9yLmNvZGUgPT09IGNvZGUgOiBlcnJvci5jb2RlID09PSBjb2RlICYmIGVycm9yLmVycm5vID09PSBlcnJubztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBncmFjZWZ1bCBjbGVhbnVwLlxuICpcbiAqIElmIGdyYWNlZnVsIGNsZWFudXAgaXMgc2V0LCB0bXAgd2lsbCByZW1vdmUgYWxsIGNvbnRyb2xsZWQgdGVtcG9yYXJ5IG9iamVjdHMgb24gcHJvY2VzcyBleGl0LCBvdGhlcndpc2UgdGhlXG4gKiB0ZW1wb3Jhcnkgb2JqZWN0cyB3aWxsIHJlbWFpbiBpbiBwbGFjZSwgd2FpdGluZyB0byBiZSBjbGVhbmVkIHVwIG9uIHN5c3RlbSByZXN0YXJ0IG9yIG90aGVyd2lzZSBzY2hlZHVsZWQgdGVtcG9yYXJ5XG4gKiBvYmplY3QgcmVtb3ZhbHMuXG4gKi9cbmZ1bmN0aW9uIHNldEdyYWNlZnVsQ2xlYW51cCgpIHtcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpciBmcm9tIG9zLnRtcGRpcigpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRUbXBEaXIob3B0aW9ucywgY2IpIHtcbiAgcmV0dXJuIGZzLnJlYWxwYXRoKChvcHRpb25zICYmIG9wdGlvbnMudG1wZGlyKSB8fCBvcy50bXBkaXIoKSwgY2IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHRtcCBkaXIgZnJvbSBvcy50bXBkaXIoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0VG1wRGlyU3luYyhvcHRpb25zKSB7XG4gIHJldHVybiBmcy5yZWFscGF0aFN5bmMoKG9wdGlvbnMgJiYgb3B0aW9ucy50bXBkaXIpIHx8IG9zLnRtcGRpcigpKTtcbn1cblxuLy8gSW5zdGFsbCBwcm9jZXNzIGV4aXQgbGlzdGVuZXJcbnByb2Nlc3MuYWRkTGlzdGVuZXIoRVhJVCwgX2dhcmJhZ2VDb2xsZWN0b3IpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBrZWVwIHRoZSB0ZW1wb3Jhcnkgb2JqZWN0IChmaWxlIG9yIGRpcikgd2lsbCBub3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdHJpZXMgdGhlIG51bWJlciBvZiB0cmllcyBiZWZvcmUgZ2l2ZSB1cCB0aGUgbmFtZSBnZW5lcmF0aW9uXG4gKiBAcHJvcGVydHkgKD9pbnQpIG1vZGUgdGhlIGFjY2VzcyBtb2RlLCBkZWZhdWx0cyBhcmUgMG83MDAgZm9yIGRpcmVjdG9yaWVzIGFuZCAwbzYwMCBmb3IgZmlsZXNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdGVtcGxhdGUgdGhlIFwibWtzdGVtcFwiIGxpa2UgZmlsZW5hbWUgdGVtcGxhdGVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbmFtZSBmaXhlZCBuYW1lIHJlbGF0aXZlIHRvIHRtcGRpciBvciB0aGUgc3BlY2lmaWVkIGRpciBvcHRpb25cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGlyIHRtcCBkaXJlY3RvcnkgcmVsYXRpdmUgdG8gdGhlIHJvb3QgdG1wIGRpcmVjdG9yeSBpbiB1c2VcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcHJlZml4IHByZWZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHBvc3RmaXggcG9zdGZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRtcGRpciB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IHdoaWNoIG92ZXJyaWRlcyB0aGUgb3MgdG1wZGlyXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB1bnNhZmVDbGVhbnVwIHJlY3Vyc2l2ZWx5IHJlbW92ZXMgdGhlIGNyZWF0ZWQgdGVtcG9yYXJ5IGRpcmVjdG9yeSwgZXZlbiB3aGVuIGl0J3Mgbm90IGVtcHR5XG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZXRhY2hEZXNjcmlwdG9yIGRldGFjaGVzIHRoZSBmaWxlIGRlc2NyaXB0b3IsIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY2xvc2luZyB0aGUgZmlsZSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRpc2NhcmREZXNjcmlwdG9yIGRpc2NhcmRzIHRoZSBmaWxlIGRlc2NyaXB0b3IgKGNsb3NlcyBmaWxlLCBmZCBpcyAtMSksIHRtcCB3aWxsIG5vIGxvbmdlciB0cnkgY2xvc2luZyB0aGUgZmlsZSBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxlU3luY09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYXMgYmVlbiBkaXNjYXJkZWRcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaXJTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZGlyZWN0b3J5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgdG1wTmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhZCBiZWVuIGRpc2NhcmRlZFxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZUNhbGxiYWNrU3luY1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmN9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c2ltcGxlQ2FsbGJhY2t9IFtuZXh0XSBmdW5jdGlvbiB0byBjYWxsIHdoZW5ldmVyIHRoZSB0bXAgb2JqZWN0IG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZnVuY3Rpb24gY29tcG9zaXRpb24uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcmFzemkvbm9kZS10bXAvaXNzdWVzLzU3fHJhc3ppL25vZGUtdG1wIzU3fVxuICpcbiAqIEBjYWxsYmFjayBzaW1wbGVDYWxsYmFja1xuICovXG5cbi8vIGV4cG9ydGluZyBhbGwgdGhlIG5lZWRlZCBtZXRob2RzXG5cbi8vIGV2YWx1YXRlIF9nZXRUbXBEaXIoKSBsYXppbHksIG1haW5seSBmb3Igc2ltcGxpZnlpbmcgdGVzdGluZyBidXQgaXQgYWxzbyB3aWxsXG4vLyBhbGxvdyB1c2VycyB0byByZWNvbmZpZ3VyZSB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndG1wZGlyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldFRtcERpclN5bmMoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLmRpciA9IGRpcjtcbm1vZHVsZS5leHBvcnRzLmRpclN5bmMgPSBkaXJTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5maWxlID0gZmlsZTtcbm1vZHVsZS5leHBvcnRzLmZpbGVTeW5jID0gZmlsZVN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLnRtcE5hbWUgPSB0bXBOYW1lO1xubW9kdWxlLmV4cG9ydHMudG1wTmFtZVN5bmMgPSB0bXBOYW1lU3luYztcblxubW9kdWxlLmV4cG9ydHMuc2V0R3JhY2VmdWxDbGVhbnVwID0gc2V0R3JhY2VmdWxDbGVhbnVwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;